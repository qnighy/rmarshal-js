import { assertEquals, assertThrows } from "@std/assert";
import type { RObject } from "./rom.ts";
import { load } from "./load.ts";

export function l(buf: number[]): RObject {
  return load(new Uint8Array(buf));
}

Deno.test("load loads something", () => {
  assertEquals(l([0x04, 0x08, 0x30]), null);
});

Deno.test("load rejects short or long data", () => {
  assertThrows(() => l([0x04, 0x08]), SyntaxError);
  assertThrows(() => l([0x04, 0x08, 0x30, 0x30]), SyntaxError);
});

Deno.test("load rejects invalid versions", () => {
  assertThrows(() => l([0x03, 0x08, 0x30]), SyntaxError);
  assertThrows(() => l([0x05, 0x08, 0x30]), SyntaxError);
  assertThrows(() => l([0x04, 0x09, 0x30]), SyntaxError);
  assertEquals(l([0x04, 0x07, 0x30]), null);
});

Deno.test("load loads nil", () => {
  assertEquals(l([0x04, 0x08, 0x30]), null);
});

Deno.test("load loads boolean", () => {
  assertEquals(l([0x04, 0x08, 0x46]), false);
  assertEquals(l([0x04, 0x08, 0x54]), true);
});

Deno.test("load loads Fixnum", () => {
  // Zero
  assertEquals(l([0x04, 0x08, 0x69, 0x00]), 0n);
  // Positive short form
  assertEquals(l([0x04, 0x08, 0x69, 0x06]), 1n);
  assertEquals(l([0x04, 0x08, 0x69, 0x7F]), 122n);
  // Negative short form
  assertEquals(l([0x04, 0x08, 0x69, 0xFA]), -1n);
  assertEquals(l([0x04, 0x08, 0x69, 0x80]), -123n);
  // Positive 1-byte form
  assertEquals(l([0x04, 0x08, 0x69, 0x01, 0x7B]), 123n);
  assertEquals(l([0x04, 0x08, 0x69, 0x01, 0xFF]), 255n);
  // Positive 2-byte form
  assertEquals(l([0x04, 0x08, 0x69, 0x02, 0x00, 0x01]), 256n);
  assertEquals(l([0x04, 0x08, 0x69, 0x02, 0xFF, 0xFF]), 0xFFFFn);
  // Positive 3-byte form
  assertEquals(l([0x04, 0x08, 0x69, 0x03, 0x00, 0x00, 0x01]), 0x10000n);
  assertEquals(l([0x04, 0x08, 0x69, 0x03, 0xFF, 0xFF, 0xFF]), 0xFFFFFFn);
  // Positive 4-byte form
  assertEquals(l([0x04, 0x08, 0x69, 0x04, 0x00, 0x00, 0x00, 0x01]), 0x1000000n);
  assertEquals(
    l([0x04, 0x08, 0x69, 0x04, 0xFF, 0xFF, 0xFF, 0x3F]),
    0x3FFFFFFFn,
  );
  // Negative 1-byte form
  assertEquals(l([0x04, 0x08, 0x69, 0xFF, 0x84]), -124n);
  assertEquals(l([0x04, 0x08, 0x69, 0xFF, 0x00]), -256n);
  // Negative 2-byte form
  assertEquals(l([0x04, 0x08, 0x69, 0xFE, 0xFF, 0xFE]), -257n);
  assertEquals(l([0x04, 0x08, 0x69, 0xFE, 0x00, 0x00]), -0x10000n);
  // Negative 3-byte form
  assertEquals(l([0x04, 0x08, 0x69, 0xFD, 0xFF, 0xFF, 0xFE]), -0x10001n);
  assertEquals(l([0x04, 0x08, 0x69, 0xFD, 0x00, 0x00, 0x00]), -0x1000000n);
  // Negative 4-byte form
  assertEquals(
    l([0x04, 0x08, 0x69, 0xFC, 0xFF, 0xFF, 0xFF, 0xFE]),
    -0x1000001n,
  );
  assertEquals(
    l([0x04, 0x08, 0x69, 0xFC, 0x00, 0x00, 0x00, 0xC0]),
    -0x40000000n,
  );
});

Deno.test("load rejects non-canonical Fixnum", () => {
  // Non-canonical positive short form of 0
  assertThrows(() => l([0x04, 0x08, 0x69, 0x05]), SyntaxError);
  // Non-canonical negative short form of 0
  assertThrows(() => l([0x04, 0x08, 0x69, 0xFB]), SyntaxError);
  // Redundant positive 1-byte form (0 to 122)
  assertThrows(() => l([0x04, 0x08, 0x69, 0x01, 0x00]), SyntaxError);
  assertThrows(() => l([0x04, 0x08, 0x69, 0x01, 0x7A]), SyntaxError);
  // Redundant positive 2-byte form (0 to 255)
  assertThrows(() => l([0x04, 0x08, 0x69, 0x02, 0x00, 0x00]), SyntaxError);
  assertThrows(() => l([0x04, 0x08, 0x69, 0x02, 0xFF, 0x00]), SyntaxError);
  // Redundant positive 3-byte form (0 to 0xFFFF)
  assertThrows(
    () => l([0x04, 0x08, 0x69, 0x03, 0x00, 0x00, 0x00]),
    SyntaxError,
  );
  assertThrows(
    () => l([0x04, 0x08, 0x69, 0x03, 0xFF, 0xFF, 0x00]),
    SyntaxError,
  );
  // Redundant positive 4-byte form (0 to 0xFFFFFF)
  assertThrows(
    () => l([0x04, 0x08, 0x69, 0x04, 0x00, 0x00, 0x00, 0x00]),
    SyntaxError,
  );
  assertThrows(
    () => l([0x04, 0x08, 0x69, 0x04, 0xFF, 0xFF, 0xFF, 0x00]),
    SyntaxError,
  );
  // Incorrect Bignum representation as Fixnum (0x40000000 to 0xFFFFFFFF)
  assertThrows(
    () => l([0x04, 0x08, 0x69, 0x04, 0x00, 0x00, 0x00, 0x40]),
    SyntaxError,
  );
  assertThrows(
    () => l([0x04, 0x08, 0x69, 0x04, 0xFF, 0xFF, 0xFF, 0xFF]),
    SyntaxError,
  );
  // Redundant negative 1-byte form (-1 to -123)
  assertThrows(() => l([0x04, 0x08, 0x69, 0xFF, 0xFF]), SyntaxError);
  assertThrows(() => l([0x04, 0x08, 0x69, 0xFF, 0x85]), SyntaxError);
  // Redundant negative 2-byte form (-1 to -256)
  assertThrows(() => l([0x04, 0x08, 0x69, 0xFE, 0xFF, 0xFF]), SyntaxError);
  assertThrows(() => l([0x04, 0x08, 0x69, 0xFE, 0x00, 0xFF]), SyntaxError);
  // Redundant negative 3-byte form (-1 to -0x10000)
  assertThrows(
    () => l([0x04, 0x08, 0x69, 0xFD, 0xFF, 0xFF, 0xFF]),
    SyntaxError,
  );
  assertThrows(
    () => l([0x04, 0x08, 0x69, 0xFD, 0x00, 0x00, 0xFF]),
    SyntaxError,
  );
  // Redundant negative 4-byte form (-1 to -0x1000000)
  assertThrows(
    () => l([0x04, 0x08, 0x69, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF]),
    SyntaxError,
  );
  assertThrows(
    () => l([0x04, 0x08, 0x69, 0xFC, 0x00, 0x00, 0x00, 0xFF]),
    SyntaxError,
  );
  // Incorrect Bignum representation as Fixnum (-0x40000000 to -0x1000001)
  assertThrows(
    () => l([0x04, 0x08, 0x69, 0xFC, 0xFF, 0xFF, 0xFF, 0xBF]),
    SyntaxError,
  );
});
