import { assertEquals } from "@std/assert";
import { ASCII_8BIT, findEncoding, type RObject, RSymbol } from "./rom.ts";
import { dump } from "./dump.ts";

function d(obj: RObject): number[] {
  return Array.from(dump(obj));
}

Deno.test("dump dumps nil", () => {
  assertEquals(d(null), [0x04, 0x08, 0x30]);
});

Deno.test("dump dumps boolean", () => {
  assertEquals(d(false), [0x04, 0x08, 0x46]);
  assertEquals(d(true), [0x04, 0x08, 0x54]);
});

Deno.test("dump dumps Fixnum", () => {
  // Zero
  assertEquals(d(0n), [0x04, 0x08, 0x69, 0x00]);
  // Positive short form
  assertEquals(d(1n), [0x04, 0x08, 0x69, 0x06]);
  assertEquals(d(122n), [0x04, 0x08, 0x69, 0x7F]);
  // Negative short form
  assertEquals(d(-1n), [0x04, 0x08, 0x69, 0xFA]);
  assertEquals(d(-123n), [0x04, 0x08, 0x69, 0x80]);
  // Positive 1-byte form
  assertEquals(d(123n), [0x04, 0x08, 0x69, 0x01, 0x7B]);
  assertEquals(d(255n), [0x04, 0x08, 0x69, 0x01, 0xFF]);
  // Positive 2-byte form
  assertEquals(d(256n), [0x04, 0x08, 0x69, 0x02, 0x00, 0x01]);
  assertEquals(d(0xFFFFn), [0x04, 0x08, 0x69, 0x02, 0xFF, 0xFF]);
  // Positive 3-byte form
  assertEquals(d(0x10000n), [0x04, 0x08, 0x69, 0x03, 0x00, 0x00, 0x01]);
  assertEquals(d(0xFFFFFFn), [0x04, 0x08, 0x69, 0x03, 0xFF, 0xFF, 0xFF]);
  // Positive 4-byte form
  assertEquals(d(0x1000000n), [0x04, 0x08, 0x69, 0x04, 0x00, 0x00, 0x00, 0x01]);
  assertEquals(d(0x3FFFFFFFn), [
    0x04,
    0x08,
    0x69,
    0x04,
    0xFF,
    0xFF,
    0xFF,
    0x3F,
  ]);
  // Negative 1-byte form
  assertEquals(d(-124n), [0x04, 0x08, 0x69, 0xFF, 0x84]);
  assertEquals(d(-256n), [0x04, 0x08, 0x69, 0xFF, 0x00]);
  // Negative 2-byte form
  assertEquals(d(-257n), [0x04, 0x08, 0x69, 0xFE, 0xFF, 0xFE]);
  assertEquals(d(-0x10000n), [0x04, 0x08, 0x69, 0xFE, 0x00, 0x00]);
  // Negative 3-byte form
  assertEquals(d(-0x10001n), [0x04, 0x08, 0x69, 0xFD, 0xFF, 0xFF, 0xFE]);
  assertEquals(d(-0x1000000n), [0x04, 0x08, 0x69, 0xFD, 0x00, 0x00, 0x00]);
  // Negative 4-byte form
  assertEquals(d(-0x1000001n), [
    0x04,
    0x08,
    0x69,
    0xFC,
    0xFF,
    0xFF,
    0xFF,
    0xFE,
  ]);
  assertEquals(d(-0x40000000n), [
    0x04,
    0x08,
    0x69,
    0xFC,
    0x00,
    0x00,
    0x00,
    0xC0,
  ]);
});

Deno.test("dump dumps Float", () => {
  // Non-finite values
  // NaN
  assertEquals(d(NaN), [0x04, 0x08, 0x66, 0x08, 0x6E, 0x61, 0x6E]);
  // Infinity
  assertEquals(d(Infinity), [0x04, 0x08, 0x66, 0x08, 0x69, 0x6E, 0x66]);
  // -Infinity
  assertEquals(d(-Infinity), [0x04, 0x08, 0x66, 0x09, 0x2D, 0x69, 0x6E, 0x66]);

  // Zeroes
  // 0
  assertEquals(d(0), [0x04, 0x08, 0x66, 0x06, 0x30]);
  // -0
  assertEquals(d(-0), [0x04, 0x08, 0x66, 0x07, 0x2D, 0x30]);

  // Integers in non-scientific notation
  // 1
  assertEquals(d(1), [0x04, 0x08, 0x66, 0x06, 0x31]);
  // -1
  assertEquals(d(-1), [0x04, 0x08, 0x66, 0x07, 0x2D, 0x31]);
  // 9007199254740992
  assertEquals(
    d(9007199254740992e+0),
    [
      0x04,
      0x08,
      0x66,
      0x15,
      0x39,
      0x30,
      0x30,
      0x37,
      0x31,
      0x39,
      0x39,
      0x32,
      0x35,
      0x34,
      0x37,
      0x34,
      0x30,
      0x39,
      0x39,
      0x32,
    ],
  );
  assertEquals(
    d(72057594037927896e+0),
    [
      0x04,
      0x08,
      0x66,
      0x16,
      0x37,
      0x32,
      0x30,
      0x35,
      0x37,
      0x35,
      0x39,
      0x34,
      0x30,
      0x33,
      0x37,
      0x39,
      0x32,
      0x37,
      0x38,
      0x39,
      0x36,
    ],
  );
  assertEquals(
    d(-9007199254740992e+0),
    [
      0x04,
      0x08,
      0x66,
      0x16,
      0x2D,
      0x39,
      0x30,
      0x30,
      0x37,
      0x31,
      0x39,
      0x39,
      0x32,
      0x35,
      0x34,
      0x37,
      0x34,
      0x30,
      0x39,
      0x39,
      0x32,
    ],
  );
  assertEquals(
    d(-72057594037927896e+0),
    [
      0x04,
      0x08,
      0x66,
      0x17,
      0x2D,
      0x37,
      0x32,
      0x30,
      0x35,
      0x37,
      0x35,
      0x39,
      0x34,
      0x30,
      0x33,
      0x37,
      0x39,
      0x32,
      0x37,
      0x38,
      0x39,
      0x36,
    ],
  );

  // Integers in scientific notation
  // "1e1"
  assertEquals(d(10), [0x04, 0x08, 0x66, 0x08, 0x31, 0x65, 0x31]);
  // "-1e1"
  assertEquals(d(-10), [0x04, 0x08, 0x66, 0x09, 0x2D, 0x31, 0x65, 0x31]);
  // "1.7976931348623157e308"
  assertEquals(
    d(1.7976931348623157e+308),
    [
      0x04,
      0x08,
      0x66,
      0x1B,
      0x31,
      0x2E,
      0x37,
      0x39,
      0x37,
      0x36,
      0x39,
      0x33,
      0x31,
      0x33,
      0x34,
      0x38,
      0x36,
      0x32,
      0x33,
      0x31,
      0x35,
      0x37,
      0x65,
      0x33,
      0x30,
      0x38,
    ],
  );
  // "-1.7976931348623157e308"
  assertEquals(
    d(-1.7976931348623157e+308),
    [
      0x04,
      0x08,
      0x66,
      0x1C,
      0x2D,
      0x31,
      0x2E,
      0x37,
      0x39,
      0x37,
      0x36,
      0x39,
      0x33,
      0x31,
      0x33,
      0x34,
      0x38,
      0x36,
      0x32,
      0x33,
      0x31,
      0x35,
      0x37,
      0x65,
      0x33,
      0x30,
      0x38,
    ],
  );

  // Non-scientific fractions
  // "0.0001"
  assertEquals(
    d(0.0001),
    [0x04, 0x08, 0x66, 0x0B, 0x30, 0x2E, 0x30, 0x30, 0x30, 0x31],
  );
  // "-0.0001"
  assertEquals(
    d(-0.0001),
    [0x04, 0x08, 0x66, 0x0C, 0x2D, 0x30, 0x2E, 0x30, 0x30, 0x30, 0x31],
  );

  // Scientific fractions
  // "9.999999999999999e-5"
  assertEquals(
    d(9.999999999999999e-5),
    [
      0x04,
      0x08,
      0x66,
      0x19,
      0x39,
      0x2E,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x65,
      0x2D,
      0x35,
    ],
  );
  // "-9.999999999999999e-5"
  assertEquals(
    d(-9.999999999999999e-5),
    [
      0x04,
      0x08,
      0x66,
      0x1A,
      0x2D,
      0x39,
      0x2E,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x39,
      0x65,
      0x2D,
      0x35,
    ],
  );
  // "5e-324"
  assertEquals(d(5e-324), [
    0x04,
    0x08,
    0x66,
    0x0B,
    0x35,
    0x65,
    0x2D,
    0x33,
    0x32,
    0x34,
  ]);
  // "-5e-324"
  assertEquals(d(-5e-324), [
    0x04,
    0x08,
    0x66,
    0x0C,
    0x2D,
    0x35,
    0x65,
    0x2D,
    0x33,
    0x32,
    0x34,
  ]);
});

Deno.test("dump dumps Symbol", () => {
  assertEquals(d("foo"), [0x04, 0x08, 0x3A, 0x08, 0x66, 0x6F, 0x6F]);
  // assertEquals(
  //   l([0x04, 0x08, 0x3A, 0x08, 0xE3, 0x81, 0x82]),
  //   RSymbol(Uint8Array.from([0xE3, 0x81, 0x82]), { encoding: ASCII_8BIT }),
  // );
  assertEquals(
    d(RSymbol(Uint8Array.from([0xE3, 0x81, 0x82]), {
      encoding: ASCII_8BIT,
    })),
    [0x04, 0x08, 0x3A, 0x08, 0xE3, 0x81, 0x82],
  );
  assertEquals(
    d("„ÅÇ"),
    [
      0x04,
      0x08,
      0x49,
      0x3A,
      0x08,
      0xE3,
      0x81,
      0x82,
      0x06,
      0x3A,
      0x06,
      0x45,
      0x54,
    ],
  );
  // assertEquals(
  //   d(RSymbol(Uint8Array.from([0x82, 0xA0]), {
  //     encoding: findEncoding("Windows-31J")!,
  //   })),
  //   [
  //     0x04,
  //     0x08,
  //     0x49,
  //     0x3A,
  //     0x07,
  //     0x65,
  //     0x6E,
  //     0x63,
  //     0x6F,
  //     0x64,
  //     0x69,
  //     0x6E,
  //     0x67,
  //     0x22,
  //     0x10,
  //     0x57,
  //     0x69,
  //     0x6E,
  //     0x64,
  //     0x6F,
  //     0x77,
  //     0x73,
  //     0x2D,
  //     0x33,
  //     0x31,
  //     0x4A,
  //   ],
  // );
});
